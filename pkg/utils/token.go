package utils

import (
	"crypto/ecdsa"
	"strings"

	"github.com/ethereum/go-ethereum/accounts"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/common/hexutil"
	"github.com/ethereum/go-ethereum/crypto"
)

// GenerateAuthenticationToken generates a commitment that can only be opened by this Builder
// This commitment represents a Authentication Token and is meant to be stored in a smart-contract.
//
// This token will be generated by the client.
func GenerateAuthenticationToken(msg string, key *ecdsa.PrivateKey) (string, error) {
	hash := crypto.Keccak256Hash([]byte(msg)).Hex()
	signature, err := crypto.Sign(accounts.TextHash([]byte(hash)), key) // We use an EIP
	token := crypto.PubkeyToAddress(key.PublicKey).Hex() + ":" + hexutil.Encode(signature)

	return token, err
}

// Returns the authenticated address and the fail/success state of the Authentication Token verification
// Note: We're ignoring the recovery id of the signature and the searcher address sent in the payload
//
// This token will be verified by the Builder running Builder Boost.
// We Ignore the address because we can recover the public key from the signature
// We request the searcher address in the payload for consistency with the ecosystem
func VerifyAuthenticationToken(token string, digest string) (common.Address, bool) {
	// Split the string token by ":""
	// The first part is the address
	// The second part is the signature
	data := strings.Split(token, ":")
	if len(data) != 2 {
		return common.Address{}, false
	}

	// Decode the signature
	signature, err := hexutil.Decode(data[1])
	if err != nil {
		return common.Address{}, false
	}

	hashDigest := crypto.Keccak256Hash([]byte(digest)).Hex()
	pubkey, err := crypto.SigToPub(accounts.TextHash([]byte(hashDigest)), signature)
	if err != nil {
		return common.Address{}, false
	}

	// Signature is 65 bytes long, with the structure [R || S || V]
	// We remove recovery id V from the signature as it's not needed for verification, only signature recovery.
	// VerifySignature paramater only takes R and S
	// https://goethereumbook.org/signature-verify/
	return crypto.PubkeyToAddress(*pubkey), crypto.VerifySignature(crypto.FromECDSAPub(pubkey), accounts.TextHash([]byte(hashDigest)), signature[:len(signature)-1])
}
